# get_io_format converts incoming data to a standard IO format. The original
#   content is added to the output in the "original_message" field automatically.
def get_io_format:
    {
        "input": .,
        "output": {
            "original_message": . | tojson
        }
    }
;

# add_field adds a key-value pair to the metadata objects generated by get_io_format
# Takes an input and output filter as parameters
# Capable of adding data to any of the objects in the metadata JSON (input, output, subrule, transform_path, etc)
# This function should be used for adding all metadata to your output - It scrubs illegal characters like | and \n
# Example function call: add_field(.input.field1; .output.subject)
def add_field($input_field; output_field):

    # input_field validation check
    if
        $input_field
    then
        # Convert input_field value as Json text string
        if 
            ($input_field | type == "string")
        then        
            # Strip out control codes and extended characters from input field value. This includes characters like: [\b \t \n \u000b \f \r \u000e \u000f]
            ($input_field | explode | map(select(. > 31)) | implode) as $strip_control
            |
            # Retain the | removal to support regex parsing in SIEM
            if ($strip_control | contains("|")) then ($strip_control | split("|") | join ("-")) as $strip_pipe else $strip_control as $strip_pipe end
            |            
            # Cleanup completed
            output_field = $strip_pipe
        else
            output_field = $input_field
        end
    else
        .
    end
;

# flatten_array will flatten or fan out the pipeline, returning n values
#  where n is the number of array records in the log message. If there are no records
#  the input is returned unchanged
def flatten_array($log_msg_field):
    if $log_msg_field then
        if ($log_msg_field | length) > 0 then
            # flatten our records into one message each
            $log_msg_field[]
        else
            .
        end
    else
        .
    end
;


# transform will normalize the incoming log into the LogRhythm Schema
#   that can then be forwarded to the SIEM
def transform:
    # First, convert to IO format.
    get_io_format |
    .input.unescaped = (.input.message | fromjson) |
    #  .input.unescaped = (.input.message | fromjson) |
    # beatname is a required field for Open Collector Regex to work in the SIEM.
    # for elastic beats, capture the beatname into our output
    # for other beats add a value to beatname code example: add_field("filebeat"; .output.beatname) |
    .input.unescaped.complianceIssues as $array |
        if ($array | type) == "array" then
            .single_log = flatten_array($array) |
            .input.unescaped.ci = ({ "complianceIssues" : [ .single_log ] })
        else
            .
        end |

    add_field(.input."@metadata".beat; .output.beatname) |
    add_field(.input.fullyqualifiedbeatname; .output.fullyqualifiedbeatname) |
    if .input.unescaped.source == "Prisma Cloud" then
        add_field(.input.unescaped.alertTs; .output.normal_msg_date) |
        add_field(.input.unescaped.reason; .output.reason) |
        add_field(.input.unescaped.alertStatus; .output.status) |
        add_field(.input.unescaped.alertRuleName; .output.vendorinfo) |
        add_field(.input.unescaped.callbackUrl; .output.url) |
        add_field(.input.unescaped.policyName; .output.policy) |
        add_field(.input.unescaped.resourceName; .output.object) |
        add_field(.input.unescaped.resourceType; .output.objecttype) |
	add_field(.input.unescaped.cloudType; .output.sessiontype) |
	add_field(.input.unescaped.accountName; .output.domainimpacted) | 
	add_field(.input.unescaped.resourceCloudService; .output.session) |
	add_field(.input.unescaped.resource.cloudAccountGroups[0]; .output.group) |
        add_field(.input.unescaped.accountOwners; .output.account) |
        add_field(.input.unescaped.alertId; .output.serialnumber) |
        add_field(.input.unescaped.policyType; .output.subject) |
        add_field(.input.unescaped.alertRuleId; .output.vmid) |
        add_field(.input.unescaped.severity; .output.severity) |
        add_field(.input.unescaped.source; .output.sender) |
    else
        add_field(.input.unescaped.type; .output.sender) |
        add_field(.input.unescaped.ci.complianceIssues[0].category; .output.subject) |
        add_field(.input.unescaped.ci.complianceIssues[0].title; .output.policy) |
        add_field(.input.unescaped.ci.complianceIssues[0].severity; .output.severity) |
        add_field(.input.unescaped.ci.complianceIssues[0].type; .output.objecttype) |
        add_field(.input.unescaped.ci.complianceIssues[0].id; .output.session) |
        add_field(.input.unescaped.ci.complianceIssues[0].cause; .output.reason) |
        add_field(.input.unescaped.container; .output.object) |
        add_field(.input.unescaped.image; .output.objectname) |
        add_field(.input.unescaped.host; .output.dname) |
        add_field(.input.unescaped.accountID; .output.account) |
        add_field(.input.unescaped.rule; .output.vendorinfo) |
    end |

    # TODO: insert transformation logic here to build output

    # this filter produces the output object, for sending to SYSLOG output
    # This filter should be left in place in most cases
    .output
;
